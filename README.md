## 스터디를 만든 이유

------

### 올바른 방향 지도

우리는 모두 같은 목표를 갖고 있습니다. SWEA B형을 취득하는 것이죠. 혼자서 해내기에 쉬운 일은 아닙니다. 무엇을 공부해야 할 지, 어떻게 연습해야 할 지 학교에서도 학원에서도 가르쳐 주지 않습니다. 그래서 길을 헤매며 지금 이대로 노력하는 게 정말 실력을 높여줄까라는 의구심도 듭니다. 노력과 시간을 쏟아부어도 눈에 띄는 결과를 얻지 못하니 자신의 부족함을 탓하기도 하죠. 노력도 능력도 부족한 게 아닙니다. 실력을 높일 올바른 방법을 모를 뿐이죠. 그래서 개인의 노력과 시간을 올바른 방향으로 투자할 수 있게끔 방향을 모색해야 합니다. 문제 해결에 발을 들인 이들이 같은 고민을 하며 제대로 된 방법을 찾아내기까지 많은 시행착오를 거듭합니다. 시간이 어느 정도가 걸릴 지 개인차가 있겠지만 결국 방법을 찾을 것입니다. 

하지만 이 영역에 입문한 이들이 똑같이 시행 착오를 겪어야 하는 것은 노력과 시간의 낭비입니다. 문제 해결 역량을 향상 시키는 방법은 정해져있기 때문입니다. 그래서 개인의 노력과 시간을 올바른 방향으로 투자할 수 있게끔 방향을 지도하는 것이 이 스터디의 첫 번째 역할입니다.



### 정보 수집하고 분석하기

B형은 A형에 비해 정보량이 지나치게 부족합니다. 지난 몇 년간 수 십 차례 B형 시험을 치렀는데도 A형과 달리 기출 문제가 한 문제도 없습니다. 정보가 이렇게 부족해서야 제대로 된 판단을 하기 어렵습니다. 시험을 치렀던 사람의 말을 흘려 듣는 것 외에 방법은 많지 않습니다. B형 시험을 치른 사람의 기억을 되살려 문제를 복원해야 합니다. 정보를 저장하고 분석해 통찰을 이끌어내고 전략을 세워 우리의 노력과 시간이 헛된 것이 되지 않게 해야 합니다. 

이 스터디의 두 번째 역할은 정보를 수집하고 분석하며 전략을 짜고 시도해 결과를 얻고 피드백한 것을 기록으로 남기는 일입니다.



### 지식 베이스 만들기

교과서에서 배운 지식은 그 지식을 관통하는 중추입니다. 그렇다고 그 모습이 지식의 모든 모습은 아닙니다. 문제를 풀며 지식을 새로운 관점으로 바라볼 수 있게 되었다면 지식의 이해가 더 넓어진 것입니다. 뼈대에 살을 붙여 지식의 온전한 모습을 만들어 가야 합니다. 알고리즘을 제대로 공부했다고 생각해도 몇 주가 지나면 알고리즘이 동작하는 모습조차 희미해질 것입니다. 다시 책을 펴고 논증 과정을 따라가고, 다시 구현을 연습하고, 다시 문제를 풀며 연습할 건가요? 기록으로 남긴다면 이 과정은 불필요합니다. 지식 베이스를 만들어 지식을 수정하고 확장하고 변형해나갈 것입니다. 쓰이기 좋은 형태로 레퍼런스 코드를 만들어 두면 기억이 나지 않더라도 조금 살펴본 것으로 기억을 상기할 수 있겠죠. 중요한 것은 이 알고리즘과 자료구조를 어떻게 써먹냐이지 글자 하나 틀리지 않고 코드를 작성하는 게 아닙니다.

이 스터디의 세 번째 역할은 지식 베이스를 만들어 이해가 확장될 때마다 지식 베이스를 보완해 나가는 것입니다.



## A형과 B형의 차이점

------

A형에서 B형으로 넘어가면 정복해야 할 문제 해결 영역이 넓어집니다. B형에서 요구하는 알고리즘과 자료구조를 숙지하는 것만으로 결코 B형에 대비할 수 없습니다. 심지어 B형 시험을 치를 때 주요 알고리즘과 자료구조가 레퍼런스로 공개되어있습니다. 오픈북 테스트처럼 느껴지지 않나요? 이런 유형의 시험은 지식을 알고 있음을 묻지 않죠. 지문을 이해하고 주어진 정보를 분석하고 잘 추론해서 실마리를 찾아야 합니다. 이를 '접근'이라고 하죠. 접근을 통해 얻은 실마리를 바탕으로 문제를 잘 정의해야 합니다. 그리고 문제를 해결하기 위한 과정을 설계해야 합니다. 그 과정의 각 단계가 하나의 소규모 문제인 셈입니다. 소규모 문제까지 정의가 끝나면 그제서야 흔히 알던 알고리즘과 자료구조를 적용할 수 있습니다.

사실 위 역량은 A형에서 요구되는 역량입니다. 어느 정도 문제를 풀면 문제만 봐도 어떻게 문제를 풀 지 그 과정이 머릿속에 자동적으로 그려지죠. 그럼에도 A형이 만만하지 않은 이유는 문제의 복잡성이 크기 때문입니다. 문제에서 제시한 제약 조건과 처리해야 할 상황이 많습니다. 문제가 너무 익숙해서 복잡성을 잘 다룰 수 있으면 상관없지만 그 정도 수준이 아니라면 복잡성을 다루기 위해 종이에 '**과정을 계획**'하고 '**각 단계를 설계**'해야 합니다. 어느 정도 복잡성을 다룰 수 있을만큼 크기를 줄이고 나서야 구현에서 실수를 줄이고 시간을 아낄 수 있습니다. 사실 A형은 B형에 비해 문제가 예쁘게 나오는 편입니다. 문제를 해결하기 위한 과정에서 각 단계가 명확하게 분리되어 있기 때문입니다.

> [17427)다리 만들기 2](https://www.acmicpc.net/problem/17472)를 예로 들어보죠. 최소한의 횟수로 다리를 설치해 각 섬을 연결하면서 설치 비용이 최소가 되게 해야 합니다. 섬들 간 연결 관계를 파악해야 하네요. **연결 관계를 표현**하려면 **그래프**가 적합하죠. 이 실마리를 쥐고 계속 생각해봅시다. 정말 주어진 정보를 그래프로 볼 수 있을까요? 
>
> 이 문제는 육지가 서로 인접해 있으면 이들을 하나의 섬으로 정의합니다. 섬과 섬을 연결할 수 있으면 그 섬에 포함된 어떤 육지여도 문제가 될 것이 없습니다. 그렇다면 각 섬을 하나의 덩어리로 볼 수 있겠군요. 덩어리를 식별하는 문제는 많이 풀어봤죠. 이런 유형의 문제를 '**그래프에서 연결요소 파악하기**'라고 합니다. BFS로 각 섬을 파악하고 인덱스를 주면 모든 섬을 식별할 수 있죠. 
>
> 일단 각 섬을 구분했다고 칩시다. 이후에는 뭘할까요? 다리를 설치해야 겠죠? 그런데 하나의 섬에는 여러 육지가 있을 수 있습니다. 그래서 한 섬에서 다른 섬에 연결되는 다리가 많을 수 있죠. 두 섬을 연결하는 데 굳이 두 개 이상의 다리를 설치할 필요는 없습니다. 그리고 여러 다리중 굳이 비용이 큰 다리를 설치할 필요는 없죠. 그렇다면 두 섬을 연결하기 위해 가장 길이가 짧은 다리 하나만 설치해야 겠네요. 두 섬을 연결하기 위한 방법을 모두 탐색해서 그 중 가장 비용이 작은 다리를 하나 찾아야 합니다. '**완전 탐색후 최적해 찾기**' 문제네요.
>
> 이제 **섬을 하나의 정점**으로 볼 수 있고 그 섬들 간에 여러 다리가 있을 수 있지만 가장 짧은 하나의 다리만 있으면 됩니다. 그 **다리를 하나의 간선**으로 볼 수 있겠네요. 따라서 정점과 가능한 연결들을 간선으로 표현할 수 있습니다. 좋아요. 문제가 단순해졌는 지 살펴봅시다. 두 가지 요구 사항이 있었습니다. 최소한의 다리로 각 섬을 연결하기. 그리고 그 비용이 가능하면 최소가 되게 하기. 그래프는 만들어 뒀다고 칩시다. 일단 현재 정점에서 다음 정점으로 가기 위한 간선을 선택해야 합니다. '**N개의 요소에서 K개를 선택하는 문제**'군요. 조합 백트래킹으로 풀 수 있습니다. 어떤 요구 사항이 남았죠? K개의 간선으로 각 정점을 모두 연결할 수 있어야 하고 그리고 그 비용이 최소가 되야 합니다. 연결성을 확인하려면 '**그래프에서 연결요소 파악하기**'  문제를 풀어야 겠죠. 그리고 연결성을 만족할 때 선택한 간선의 총비용을 후보해로 생각할 수 있고 그 후보해중 하나가 최적해가 되겠죠. 결국 '**완전 탐색후 최적해 찾기**' 문제를 풀어야 합니다.

위 과정에서 연결 관계를 그래프로 다뤄야 겠다라고 생각한 부분이 바로 **접근**입니다. 타당한 추론이죠. 문제에서 최소한의 간선으로 연결성을 유지하면서 그 비용이 최소가 되게 해야함을 요구했으니까요. 이후에 접근을 통해 얻은 실마리로 생각을 전개하며 소단위 문제를 하나씩 식별하고 있죠. 바꿔말하면 **내가 알고 있는만큼만 문제가 보인다**는 뜻이기도 합니다. 사실 이 문제를 해결하는 알고리즘이 MST입니다. MST가 어떤 문제를 다루는 지 알고 있었다면 훨씬 더 쉽게 문제를 정의할 수 있었겠죠. 왜 문제를 정의할까요? **문제를 정의하면 그 문제를 해결하는 알고리즘만 가져다 쓰면되기 때문**입니다. 정말 그래프 문제로 정의할 수 있다면 그래프 문제를 다루기 위한 알고리즘을 가져다 쓰기만 하면 끝입니다. 대신 알고리즘을 사용할 수 있는 조건을 정확히 지키고 있는 지 제대로 파악해야 합니다. 그렇지 않다면 내가 고른 알고리즘이 올바른 결과를 계산함을 보장할 수 없습니다. 당연한 결과죠. 특정 조건에서 그 알고리즘이 잘 동작한다는 것만 증명되어 있기 때문입니다. 가중치가 있는 그래프에서 최단 거리를 찾는 문제인데 BFS를 사용하면 안되겠죠.

이처럼 A형은 접근하고 문제를 정의하기까지 생각을 전개하는 일이 어렵지 않습니다. 문제를 모두 식별하고 정의하면 과정을 계획하고 필요에 따라 각 단계를 설계하고 이를 구현에 옮기기까지 척척 진행할 수 있습니다. B형은 접근 자체가 어렵습니다. 백준에서 플레티넘 티어의 문제들이 B형의 어려움과 비슷합니다. 힙을 배우고 힙으로 분류된 문제에서 골드 티어 문제로 연습하다가 풀 문제가 없어서 플레티넘 문제를 풀게됩니다. 문제를 읽고 나면 이런 생각이 들죠. '왜 이 문제가 힙으로 분류되어 있지?' 왜 힙을 써야하는 지 도무지 모르겠으니 문제 분류가 잘못됬다 생각하기도 합니다. 이럴 때 "문제에 손도 못대겠다"고 하죠. 괜히 B형이 A형보다 100배 어렵다는 얘기가 나온게 아닙니다. A형을 목표로 공부한 사람들이 풀었던 문제들은 대개 접근의 비중이 크지 않았습니다. 문제를 조금만 읽어도 "그래프 문제네", "완전 탐색 문제네" 라고 직감할 수 있기 때문이죠. 그래서 **주어진 정보를 분석하고 추론하여 실마리를 얻는 과정인 접근을 연습할 기회가 거의 없었습니다**.

B형은 A형에 비해 접근의 비중이 아주 큽니다. 그래서 플레티넘 문제를 풀어보며 접근을 연습해야 합니다. 플레티넘 문제를 풀고나면 알고리즘이 이런 식으로도 쓰일 수 있구나를 깨닫게 됩니다. **알고리즘에 대한 이해가 한 폭 더 넓어진 것**입니다. 이때 '**그 알고리즘이 어떻게 쓰였는가**'와 '**접근 방식**'을 정리해야 합니다. **아는 만큼만 문제를 식별할 수 있기 때문**입니다. 그렇지 않으면 실전에서 별별 접근을 시도하며 올바른 접근을 유도하는 고단한 추론 과정을 거쳐야 합니다. 시간적 압박, 경쟁자의 타자 소리 등의 주변 상황으로 긴장한 상황에서는 역설적이게도 아는만큼만 접근을 시도하게 됩니다. 새롭고 신박한 생각을 하기에 어려운 환경이죠. 그래서 B형 문제를 처음 접하는 사람들은 문제에 손도 못대는 경우가 많습니다. 따라서 평소에 충분한 시간을 들여 추론을 통해 올바르게 접근하는 연습을 해야 합니다. 그리고 그 연습을 통해 이해가 확장되었다면 다시 쓰일 수 있음을 명심하고 이를 정리해야 합니다.

B형의 어려움은 여기서 끝나지 않습니다. 문제의 복잡성도 아주 큽니다. 그래서 A형에서 요구되는 역량을 기본적으로 갖추고 있어야 합니다. 바로 **복잡성을 다룰 수 있는 역량**이죠. 저는 복잡성을 다루기 위해 두 가지 도구를 사용합니다. 이 도구들에 대해 간략히 짚어보죠. 

첫째는 **문제 해결 과정**입니다. 크게 **문제 이해**, **분석 및 접근**, **과정 계획**, **설계**로 구분됩니다. 이 과정에서 문제를 해결할 수 있는 솔루션이 거의 나오게 됩니다. 각 단계를 거치며 솔루션에서 모호함이 사라집니다. **구현**은 컴퓨터가 솔루션을 수행할 수 있게끔 언어로 옮기는 과정입니다. **디버깅**은 구현 결과를 확인하고 코드를 수정하는 과정이죠. A형을 연습하는 사람들이 흔히 겪는 문제는 정해진 시간 동안 2문제를 풀지 못한다는 점입니다. 왜 그럴까요? 이들은 머리속으로 복잡성을 다룰 수 있는 만큼 충분히 연습하지 않았는데 **문제를 이해하고 바로 구현 단계로 넘어가죠**. 머리속에 직감적으로 떠오른 생각이 솔루션이라 생각한 것입니다. 처음 떠오른 생각이 아무리 참신하든 **문제를 해결하기에 모호하다**는 점을 명심해야 합니다. 이들은 처음 떠오른 모호한 솔루션을 구현에 옮기다가 많은 결정 사항에 부딪힙니다. 더 작은 문제들이 있음을 구현에 가서야 깨닫죠. 작은 문제들을 해결하고 나니 또 작은 문제들이 보입니다. 그 문제를 해결하고 프로그램을 실행했더니 이번에는 잘못된 결과가 나옵니다. 어디에 문제가 있는 지 방대하고 복잡한 논리를 다시 하나씩 살펴봐야 하죠. 결국 디버깅하는데 대부분의 시간을 쓰게 됩니다. 이들은 평소에 브론즈, 실버 문제로 A형을 준비해왔습니다. 골드 문제는 가끔 시도해볼만 한 문제였죠. 그래서 문제 해결 과정을 연습할 기회도 적었고 그렇게 문제를 해결해야 한다는 점도 깨닫기 어려웠습니다.

둘째는 **디자인 원칙**입니다. '**기능 분리**', '**추상화**', **종이에 생각을 저장하기**', '**일관된 표현 사용하기**', '**직관적인 이름 사용하기**' 등이 있습니다. 이 원칙들은 제가 문제를 해결할 때 무의식적으로 시도했던 전략들 중 유효했던 전략이 습관으로 굳은 것입니다. 가장 중요한 기능 분리와 추상화에 대해서만 간략히 짚고 넘어가겠습니다. 접근을 통해 생각을 전개하면 문제가 대부분 정의됩니다. 그러면 과정 계획 단계에서 각 문제를 다루기 위한 알고리즘과 자료구조를 가져다 쓸 수 있죠. 이 단계에서 좀더 쉽게 복잡성을 다루기 위해 기능을 분리합니다. 다리 만들기2 문제에서도 연결성을 두 번 확인해야 했죠. 그렇다면 BFS를 하나만 쓰는 게 좋을까요? 같은 기능이여도 다루는 정보의 속성이 다릅니다. 하나는 인접해 있는 육지를 하나의 섬으로 간주하기 위함이고 다른 하나는 선택된 간선들로 각 정점들을 방문할 수 있는 지를 확인하기 위함입니다. 하나의 BFS로 다른 속성의 정보를 다루려면 매개변수가 많이 필요할겁니다. 코드는 짧아지겠지만 복잡성은 더 커지겠죠. 그리고 연결 요소를 파악하려면 BFS 한 번만 수행해서 끝날 일이 아닙니다. 한 번 발견했던 노드를 재발견하지 않게끔 막아야하고 다음 연결 요소를 파악하기 위해 한 번 더 BFS를 수행해야 하죠. 정리하면 '초기화', 'BFS', '어떤 연결요소에도 포함되지 않는 연결요소에 대해 BFS 수행' 기능 등이 필요합니다. 하나의 작은 문제를 해결하기 위해 필요한 과정을 여러 기능을 분리했습니다. 이들의 구현체를 하나의 함수에 때려 박는 것보다 각각을 함수로 구현한 후 그 함수들을 한 단계 더 추상화하는 것이 복잡성을 다루기에 용이합니다. 이제 우리는 그 함수가 '연결요소를 식별'하는 기능만 있다고 생각해도 문제될 것이 없습니다. 한 단계 아래에서 더 작은 소단위 문제를 잘 해결하고 있기 때문이죠. 기능 분리와 추상화를 잘 하면 복잡성을 쉽게 다룰 수 있게 됩니다. 단지 기능 몇 개만으로 과정을 계획할 수 있게 되죠. 코드 라인은 100줄을 가뿐히 넘기겠지만 추상화된 개념을 다루기 때문에 실제 문제를 해결하기 위한 전체 논리는 10줄이 채 되지 않을 겁니다.

 B형 문제가 얼마나 복잡하길래 복잡성을 잘 다뤄야 하는 걸까요? 몇 가지 예를 들어서 맛만 보도록 합시다. 아래 기술한 내용을 지금 이해할 필요는 없습니다.

> 힙에 지원하지 않는 연산이 있죠. 특정 원소를 지정해 그 원소의 우선순위를 높이거나 낮추려면 어떻게 해야 할까요? 힙은 배열로 표현하기 때문에 각 노드를 인덱스로 지정할 수 있지만 노드가 삽입되거나 삭제되면 힙의 성질을 유지하기 위해 깨진 구조를 고쳐야 합니다. 그래서 어떤 항목이든 항상 자기 자리에 있음을 보장할 수 없습니다. 따라서 항목에 대한 인덱스를 힙 외부에서 계속 유지하고 있어야 합니다. 힙의 구조가 바뀔 때 각 항목의 위치가 바뀌면 각 항목과 대응하는 인덱스도 바뀌어야 합니다. 어디다 써먹을까요? 작업 스케쥴링할 때 써먹습니다. 우선순위 큐처럼 작업에 대한 순서를 우선 순위 순으로 유지하면서 긴급하게 처리해야 할 서비스가 큐에서 대기하고 있다면 큐에서 그 서비스를 찾아서 우선순위를 높여줘야 합니다. 힙의 성질이 깨질테니 힙의 구조를 고쳐야 하고 구조가 바뀜에 따라 각 서비스에 대한 인덱스도 바뀌겠죠. 인덱스 리스트도 새로 갱신해야 합니다. 
>
> 힙과 각 노드에 대한 인덱스를 유지하는 리스트를 표현하면 이런 모습이겠죠.
>
> ![힙 특정 원소 갱신](./images/HeapUpadate.png)



> 셀 병합이라는 문제가 출제된 적이 있습니다. 문제의 요구사항은 이러했습니다. 셀에 문자열을 저장할 수 있습니다. 셀을 서로 합칠 수도 있습니다. A를 B에 합치면 합친 셀의 문자열은 B셀의 문자열을 따라갑니다. 입력으로 주어지는 문자열은 중복이 없기 때문에 어떤 문자열을 검색하면 그 문자열을 포함하는 셀 집합을 알 수 있어야 합니다. 반대로 셀 좌표로 어떤 셀을 선택하면 그 셀이 포함된 셀의 집합을 알 수 있어야 하고 그 셀 집합이 저장하고 있는 문자열도 알 수 있어야 하죠. 탐색형 자료구조를 어느 정도 공부를 했다면 어떤 자료구조가 적합한 지 머리속에 떠오를 겁니다. 문자열로 셀에 접근할 수 있어야 합니다. 문자열이 키, 셀이 항목인 키-값 구조로 항목을 저장하는 <u>연관 배열</u>을 사용해야 하죠. 손쉽게 구현할 수 있는 자료구조로 <u>해시 테이블</u>과 <u>트라이</u>가 떠오릅니다. 특정 셀을 지정했을 때 셀 그룹도 지정할 수 있어야 합니다. 어떤 셀도 두 개 이상의 셀 그룹에 포함될 수 없죠. 그렇다면 셀 그룹을 <u>상호 배타적 집합</u>으로 표현할 수 있습니다. 상호 배타적 집합은 <u>유니온 파인드</u>로 구현할 수 있겠죠. 그리고 셀 좌표를 알고 있다면 그 셀에 직접 접근할 수 있어야 합니다. 셀 공간만큼의 <u>이차원 배열</u>을 할당하면 되겠죠. 하지만 셀에 대한 정보는 연관 배열에서도 관리하기 때문에 연관 배열의 셀 항목과 이차원 배열의 셀 항목이 서로 일대일 대응해야 합니다. 그리고 그 셀을 포함하는 셀 그룹도 알 수 있어야 하죠. 셀 하나에 세 개의 자료 구조가 얽히게 되는 셈입니다. 꽤 복잡하죠? 요구 사항을 만족하는 자료구조는 어떤 모습일까요?
>
> 해시 테이블로 구현하면 이런 모습이겠죠.
>
> ![셀 병합 with 해시 테이블](./images/withHashTable.png)
>
> 트라이로 구현하면 이런 모습일겁니다.
>
> ![셀 병합 with 트라이](./images/withTrie.png)

맛이 어떤가요? 입에 넣자마자 빼고 싶은 맛일 겁니다. 너무 인상 찌푸릴 필요는 없습니다. 스터디를 통해 기초부터 응용까지 완벽하게 다져 나가며 쓴맛도 맛있게 조리하는 방법을 익히게 될 테니까요.

정리해봅시다.

A형은 알고리즘, 자료구조의 범위가 좁습니다. 문제를 많이 풀면 그림만 봐도 어떻게 풀어야 할 지 느낌이 옵니다. 어떻게 문제를 해결할 지, 어떻게 접근할 지 고민할 필요가 없죠. 그래도 A형 시험이 만만하지 않은 이유는 여러 조건, 제약 사항, 상황별 동작들이 주어지기 때문에 복잡성을 관리하는 데 어려움을 느끼기 때문입니다. 저는 복잡성을 관리하기 위해 두 가지 도구를 제시했습니다. 문제 해결 과정과 디자인 원칙이었죠. 

B형에서는 A형보다 복잡성을 더 잘 다뤄야 합니다. 기능 분리를 체득하면 얽히고 섥힌 동작을 분리하는 나름의 기준을 얻고 어떤 단위로 분리하는 게 좋을지 직관적으로 판단할 수 있습니다. 그 기능들을 이용해 소단위 문제를 해결할 수 있겠죠. 추상화의 중요성을 느꼈다면, 하나의 문제를 해결하기 위한 기능 집합을 추상화하는 것은 선택이 아니라 필수라는 데에 동의할 겁니다. 몇 차원 추상화된 기능으로 손 쉽게 솔루션을 작성할 수 있습니다. 또 기능 분리와 추상화를 잘 했다면 기능들을 서로 연결함에 있어 다른 기능을 고려하지 않아도 문제가 없습니다. B형을 A형보다 어렵게 만든 주요 요인은 바로 접근 단계입니다. 주어진 지문에서 얻은 정보를 분석하고 추론해서 문제를 정의할 수 있는 실마리를 얻어야 합니다. 그 실마리를 시작으로 생각을 전개하며 소단위 문제들을 정의해나가야 합니다. 소단위 문제가 정의되면 평소에 연습했던 대로 알고리즘을 가져다 쓰기만 하면 그만입니다. 하지만 우리는 평소에 문제에 접근하는 연습을 해본 적이 거의 없습니다. 그래서 문제를 읽어도 손을 못댑니다.

조만간 '**접근을 위해 알고리즘, 자료구조를 어떻게 학습하고 훈련해야 하는가**', '**문제 해결 과정**', '**디자인 원칙**'을 주제로 포스팅할 계획입니다. 


## 스터디 규칙

------

### 결국 학습과 훈련은 혼자서 해야한다

문제 해결 영역은 지식을 많이 갖고 있다고 정복할 수 있는 영역이 아닙니다. 누군가 지식을 이해하기 쉽게 잘 전달해서 절로 고개를 끄덕여도 그 지식이 내 것이 됬다고 할 수 없습니다. 지식을 토씨하나 틀리지 않고 꺼낼 수 있게 됬다고 내 것이 된 게 아닙니다. 그 지식이 진정 내 것이 될려면 자유 자재로 사용할 수 있어야 합니다. 문제를 해석하는 관점이 될 수도 있고 어떤 결정을 내릴 때 판단의 근거로 사용할 수 있어야 합니다. 그 지식의 사소한 한 부분 조차 잘 이해하고 있어서 그 부분이 바뀌었을 때 결과가 어떻게 바뀔 지 예측할 수 있어야 합니다. 그 점을 응용해 문제를 해결할 수 있어야 하죠. 이 일을 누가 해주나요? 지식을 사용하는 훈련은 스스로 해야 합니다. 누군가 통찰의 경험을 공유하더라도 나 또한 통찰을 경험하려면 논증 과정을 따라가야 합니다. 이 스터디가 제시하는 방향을 따라가며 시간과 노력을 투자하세요. 



### 지식의 이해를 넓혔다면 팀 노트에 추가하라

안타깝게도 교과서에 담긴 지식은 지식의 다양한 모습을 모두 담아낼 수 있는 것은 아닙니다. 교과서는 지식의 핵심적인 뼈대만 알려줍니다. 문제를 오랫동안 고민하며 결국 문제를 해결했을 때 내가 알고 있는 지식의 다른 면을 깨닫게 됩니다. 지식에 대한 이해가 더 넓어진 순간이죠. 이 순간을 기록으로 남겨야 합니다. 앞서 말했듯이 확장된 지식은 어떤 형태로든 다시 쓰입니다. 특히 접근 방식과 같은 지식은 모양을 바꾸기가 용이해 여러 문제들에 대해 이리저리 끼워 맞출 수 있습니다. 문제를 기억하는 게 아니라 이해가 확장된 지식을 기억해야 합니다. 실전에서 마주하는 문제들은 예전에 한 번도 풀어본 적 없던 문제인 경우가 많습니다. 지식은 크기가 정해지고 고정된 형태가 아니라 유동적이고 모양이 쉽게 변할 수 있음을 깨닫는다면 지식을 관리하는 지식 베이스가 필요함을 이해할 수 있습니다.



### 각자가 스터디를 이끌어 갈 책임을 갖는다

이 일 모두 한 사람이 감당하기에 규모가 큽니다. 그래서 함께 스터디를 만들어 가야 합니다. 또한 각자의 관점과 생각이 모두 다르기 때문에 문제를 바라볼 수 있는 시각도 다양해집니다. 그러나 수동적으로 따라가기만 해서는 개인에게도 공동체에게도 그다지 도움이 되지 않습니다. 리더가 이끌어 나가되 스터디원 각자는 주도적으로 학습과 훈련을 해야합니다. 추가적으로 자료를 조사해 리더가 이끌어가는 방향을 조정하거나 보완할 수도 있겠죠. 문제를 풀고 새롭게 이해를 넓혔다면 문제를 정의하기까지 추론 과정과 관점을 바꾸면 이렇게도 생각할 수 있음을 기록해야 합니다. 누구나 그런 권리를 갖습니다.



## 진행 방식

------



- 리더는 한 주 동안 스터디할 알고리즘 또는 자료구조 하나를 선택합니다.
- 리더는 스터디원들이 월요일부터 공부할 수 있게끔 자료를 준비하고 알려줘야 합니다. 어떻게 스터디를 진행할 지 개괄을 알 수 있게끔 목차를 제시합니다. 목차를 제시하면 스터디원들이 어떤 방향으로 스터디를 진행하며 자료 간 연관성을 쉽게 파악할 수 있습니다.
- 모든 스터디원이 월요일부터 수요일까지 주어진 자료를 학습합니다. 공부하면서 각자 수준에 맞는 문제를 하나씩을 골라주세요.
- 스터디원이 주어진 자료를 학습하면서 리더의 방향에 보완할 점 또는 이것도 다뤄야 할 것같다는 점이 있다면 추가적으로 자료를 조사해도 됩니다.
- 수요일 저녁에 리더가 스터디를 진행합니다. 목차를 제시하고 다루고자 하는 내용의 연관성을 설명해주세요. 스터디원 모두가 학습했다고 가정합니다. 리더는 알고리즘이 등장한 배경, 인터페이스, 알고리즘의 동작, 그 쓰임새 등을 간단하게 짚고 넘어가되 스터디원이 물어본다면 이해할 수 있게끔 자세하게 설명합니다. 스터디원이 추가 자료를 가져와 리더가 다룬 내용이 보완하거나 수정이 필요한다면 왜 그런지 어떻게 해야하는 지 간단하게 발표해주세요.
- 스터디가 끝나면 각자가 고른 문제를 공유합니다. 모든 스터디원들은 수요일부터 금요일까지 스터디원들이 고른 문제를 풉니다.
- 금요일 날 자신이 고른 문제를 어떻게 풀었는 지 간략하게 발표합니다. 알고리즘이 어떻게 동작하는 지 상세하게 설명할 필요는 없습니다. 중요한 것은 그 문제를 풀기까지의 사고 과정입니다. 자신이 생각하기에 바로 이 부분이 문제를 풀어 내기위한 키 포인트였다면 그 점을 강조해주세요.
- 코드 리뷰가 끝나면 다음 주에 스터디를 진행할 리더를 정합니다. 다음 주 리더는 다음 주에 스터디할 주제에 대해 공부하고 자료를 조사해야 합니다.
- 이번 주 리더는 이번 주에 다뤘던 내용을 정리해주세요. 목차를 따라가며 학습하고 스터디를 하며 피드백받은 부분을 복습한다고 생각하고 정리하면 됩니다.(레퍼런스 코드는 제가 작성하겠습니다.)
- 스터디 원들은 자신이 고른 문제가 새로운 접근 방식을 필요로 했거나 알고리즘을 변형하는 등 생각의 전환이 필요했다면 리더가 작성한 내용 밑에 덧보태면 됩니다.
- 나중에 스터디원들이 문제를 풀 때 새로운 관점이 필요했다면 누구나 팀 노트를 보완할 수 있습니다.



## 커리큘럼

------

작성 예정
